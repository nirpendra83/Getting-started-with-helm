var relearn_searchindex = [
  {
    "breadcrumb": "",
    "content": "Table of Contents 📌 Introduction to Helm What is Helm? Why use Helm for Kubernetes application deployment? Key components: Charts, Repositories, Releases 📚 Exploring the Official Helm Documentation Navigating helm.sh/docs Installation and prerequisites Understanding the Helm CLI and commands Helm 3 vs Helm 2 (brief overview) 🧩 Working with Existing Helm Charts 🔍 Discovering and Using Helm Repositories Adding public and private chart repositories Searching for charts (helm search hub vs helm search repo) Repository management commands 🚀 Deploying a Helm Release Installing a chart as a release Setting a namespace for the deployment Dry run and debug before actual deployment ⚙️ Customizing Charts with Values Understanding values.yaml Overriding values using: Custom values.yaml files --set CLI option --set-file and --set-string 🔁 Managing Helm Releases Upgrading a release with updated values or chart versions Rolling back to a previous release version Viewing and diffing historical release versions Uninstalling a release cleanly 🌐 Multi-Environment Helm Usage Structuring values for different environments (dev, staging, prod) Folder-based environment separation Using --values with multiple files for environment-specific configs 🛠️ Creating Your Own Helm Charts ⚡ Helm Chart Quick Start helm create mychart Directory structure explained Modifying the default template 🧬 Helm Template Engine and Syntax How Helm renders templates Using {{ .Values }}, {{ .Chart }}, {{ .Release }} objects 🏗 Built-in Objects and Functions Overview of available Helm objects Useful template functions (include, required, lookup, toYaml, etc.) Best practices in chart templating 🧪 Testing and Validating Charts helm lint and template validation Using helm template for local rendering Unit testing templates with tools like helm-unittest 🧰 Troubleshooting and Tips Debugging with --debug and --dry-run Common errors and how to fix them Checking logs and Helm release history Understanding exit codes and command output",
    "description": "Table of Contents 📌 Introduction to Helm What is Helm? Why use Helm for Kubernetes application deployment? Key components: Charts, Repositories, Releases 📚 Exploring the Official Helm Documentation Navigating helm.sh/docs Installation and prerequisites Understanding the Helm CLI and commands Helm 3 vs Helm 2 (brief overview) 🧩 Working with Existing Helm Charts 🔍 Discovering and Using Helm Repositories Adding public and private chart repositories Searching for charts (helm search hub vs helm search repo) Repository management commands 🚀 Deploying a Helm Release Installing a chart as a release Setting a namespace for the deployment Dry run and debug before actual deployment ⚙️ Customizing Charts with Values Understanding values.yaml Overriding values using: Custom values.yaml files --set CLI option --set-file and --set-string 🔁 Managing Helm Releases Upgrading a release with updated values or chart versions Rolling back to a previous release version Viewing and diffing historical release versions Uninstalling a release cleanly 🌐 Multi-Environment Helm Usage Structuring values for different environments (dev, staging, prod) Folder-based environment separation Using --values with multiple files for environment-specific configs 🛠️ Creating Your Own Helm Charts ⚡ Helm Chart Quick Start helm create mychart Directory structure explained Modifying the default template 🧬 Helm Template Engine and Syntax How Helm renders templates Using {{ .Values }}, {{ .Chart }}, {{ .Release }} objects 🏗 Built-in Objects and Functions Overview of available Helm objects Useful template functions (include, required, lookup, toYaml, etc.) Best practices in chart templating 🧪 Testing and Validating Charts helm lint and template validation Using helm template for local rendering Unit testing templates with tools like helm-unittest 🧰 Troubleshooting and Tips Debugging with --debug and --dry-run Common errors and how to fix them Checking logs and Helm release history Understanding exit codes and command output",
    "tags": [],
    "title": "Helm Table of Contents",
    "uri": "/helm/toc/index.html"
  },
  {
    "breadcrumb": "",
    "content": "📦 What is Helm? Helm is a package manager for Kubernetes that helps you define, install, and manage applications in your Kubernetes clusters.\nIt simplifies the deployment process by using reusable, shareable packages called charts — which bundle together YAML configurations for Kubernetes resources.\nHelm makes it easy to install and manage apps on Kubernetes. Instead of writing many config files, Helm bundles them so you can install apps with just one command. It helps you upgrade or roll back apps easily if something goes wrong. You can customize apps by changing simple settings instead of editing complex files. Helm has lots of ready-made app packages (called charts) that you can use and share. It keeps track of what you installed, so managing your apps is simpler. 🧰 Helm: APT or YUM for Kubernetes Just like APT on Debian-based systems or YUM on Red Hat-based systems manages Linux packages, Helm manages Kubernetes applications.\n💡 How It Works On Linux: You install NGINX using APT:\nsudo apt install nginx On Kubernetes with Helm: You install NGINX using a Helm chart:\nAdd Helm repo first\nhelm repo add bitnami https://charts.bitnami.com/bitnami Update the repo\nhelm repo update Install Nginx Application (package)\nhelm install my-nginx bitnami/nginx This command pulls a chart from a repository, creates the necessary Kubernetes resources, and deploys the application in your cluster.\n🚀 Why Use Helm? 1. 📦 Package Management Helm charts are similar to .deb or .rpm packages — they package everything needed for an application, including deployments, services, config maps, and secrets.\n2. 🕒 Version Control You can install specific versions of applications, just like with package managers:\nhelm install my-nginx bitnami/nginx --version 13.0.0 This makes upgrades and rollbacks safe and predictable.\n3. ⚙️ Configuration Management Override default settings using values files:\nhelm install my-nginx bitnami/nginx --values custom-values.yaml Or via the command line:\nhelm install my-nginx bitnami/nginx --set service.type=NodePort This makes deployments flexible and environment-specific.\n4. 🔗 Dependency Management Helm handles dependencies between components, ensuring that services like databases are deployed and ready before dependent apps are installed — just like APT resolves software dependencies.\n🧠 Why Helm Is Essential Kubernetes involves managing multiple YAML files for services, deployments, config maps, secrets, and more. Helm bundles all these into a single chart that can be versioned, shared, and deployed with one command. This approach brings consistency, reusability, and efficiency to Kubernetes application lifecycle management.\nHelm is widely adopted in CI/CD pipelines, GitOps workflows, and is considered a standard for Kubernetes package management.",
    "description": "📦 What is Helm? Helm is a package manager for Kubernetes that helps you define, install, and manage applications in your Kubernetes clusters.\nIt simplifies the deployment process by using reusable, shareable packages called charts — which bundle together YAML configurations for Kubernetes resources.\nHelm makes it easy to install and manage apps on Kubernetes. Instead of writing many config files, Helm bundles them so you can install apps with just one command. It helps you upgrade or roll back apps easily if something goes wrong. You can customize apps by changing simple settings instead of editing complex files. Helm has lots of ready-made app packages (called charts) that you can use and share. It keeps track of what you installed, so managing your apps is simpler. 🧰 Helm: APT or YUM for Kubernetes Just like APT on Debian-based systems or YUM on Red Hat-based systems manages Linux packages, Helm manages Kubernetes applications.",
    "tags": [],
    "title": "What is Helm?",
    "uri": "/helm/01.helm/index.html"
  },
  {
    "breadcrumb": "",
    "content": "Helm Chart Helm Repository Helm CLI Helm Release 🧱 Helm Charts A Helm chart is a packaged collection of Kubernetes resource definitions required to deploy applications. Think of it like a .deb or .rpm package in Linux — reusable, shareable, and version-controlled.\n📦 Chart Structure mychart/ ├── Chart.yaml # Metadata about the chart (name, version, description) ├── values.yaml # Default config values for templates ├── charts/ # Optional: subcharts (dependencies) ├── templates/ # Kubernetes manifest templates │ ├── deployment.yaml │ ├── service.yaml │ ├── _helpers.tpl # Reusable template snippets │ └── ... └── README.md # Optional: chart documentation 📄 Key Files Chart.yaml – Metadata about the chart (name, version, description) values.yaml – Default configuration values; can be overridden at install/upgrade templates/ – Kubernetes manifests rendered with Go templating charts/ – Subcharts or dependencies README.md – Optional documentation 🛠️ Create a New Chart helm create myapp This generates a scaffolded chart directory under myapp/.\n🚀 Install a Chart helm install my-nginx bitnami/nginx 📚 Helm Repositories A Helm repository is a remote or local source that hosts one or more Helm charts, similar to APT/YUM repos in Linux.\n➕ Add a Repository helm repo add bitnami https://charts.bitnami.com/bitnami 📋 List Configured Repositories helm repo list 🔄 Update Repository Cache helm repo update Repositories enable you to distribute and manage versioned charts in a structured manner.\n🚢 Helm Releases A Helm release is a deployed instance of a chart in your Kubernetes cluster. Each release is uniquely named and tracks the chart version, configuration values, and revision history.\n🚀 Install / Create a Release helm install myapp ./myapp 📜 List All Releases helm list 🔧 Upgrade a Release helm upgrade myapp ./myapp ⏪ Roll Back to a Previous Revision helm rollback myapp 1 ❌ Delete a Release helm uninstall myapp Releases provide full control over versioning, rollback, and lifecycle management of your Kubernetes apps.\n🧰 Common Helm CLI Commands # Add a repository helm repo add \u003cname\u003e \u003curl\u003e # Update repository cache helm repo update # Search for a chart helm search repo \u003ckeyword\u003e # Install a chart helm install \u003crelease-name\u003e \u003cchart-name\u003e # List installed releases helm list # Upgrade a release helm upgrade \u003crelease-name\u003e \u003cchart-name\u003e # Roll back a release helm rollback \u003crelease-name\u003e \u003crevision-number\u003e # Uninstall a release helm uninstall \u003crelease-name\u003e 🧠 Summary Helm Charts: Packaged applications with templated Kubernetes manifests. Helm Repositories: Storage locations for Helm charts (public or private). Helm Releases: Deployed and versioned instances of a chart within a cluster. Helm CLI: Command-line interface for managing charts, releases, and repos. Helm streamlines application deployment on Kubernetes by bringing structure, reusability, and lifecycle control to complex workloads.",
    "description": "Helm Chart Helm Repository Helm CLI Helm Release 🧱 Helm Charts A Helm chart is a packaged collection of Kubernetes resource definitions required to deploy applications. Think of it like a .deb or .rpm package in Linux — reusable, shareable, and version-controlled.\n📦 Chart Structure mychart/ ├── Chart.yaml # Metadata about the chart (name, version, description) ├── values.yaml # Default config values for templates ├── charts/ # Optional: subcharts (dependencies) ├── templates/ # Kubernetes manifest templates │ ├── deployment.yaml │ ├── service.yaml │ ├── _helpers.tpl # Reusable template snippets │ └── ... └── README.md # Optional: chart documentation 📄 Key Files Chart.yaml – Metadata about the chart (name, version, description) values.yaml – Default configuration values; can be overridden at install/upgrade templates/ – Kubernetes manifests rendered with Go templating charts/ – Subcharts or dependencies README.md – Optional documentation 🛠️ Create a New Chart helm create myapp This generates a scaffolded chart directory under myapp/.",
    "tags": [],
    "title": "Helm Components",
    "uri": "/helm/03-helm/index.html"
  },
  {
    "breadcrumb": "",
    "content": "Please visit official doc helm charts development\n🧪 Example: Custom NGINX Helm Chart Structure Create a new Helm chart:\nhelm create nginx-demo cd nginx-demo Then modify or replace the following files:\n📁 Chart.yaml apiVersion: v2 name: nginx-demo description: A Helm chart for deploying NGINX type: application version: 0.1.0 appVersion: \"1.25.2\" 📄 values.yaml replicaCount: 2 image: repository: nginx pullPolicy: IfNotPresent tag: \"1.25.2\" service: type: ClusterIP port: 80 ingress: enabled: false resources: {} nodeSelector: {} tolerations: [] affinity: {} ⚙️ templates/deployment.yaml apiVersion: apps/v1 kind: Deployment metadata: name: {{ include \"nginx-demo.fullname\" . }} labels: {{- include \"nginx-demo.labels\" . | nindent 4 }} spec: replicas: {{ .Values.replicaCount }} selector: matchLabels: app: {{ include \"nginx-demo.name\" . }} template: metadata: labels: app: {{ include \"nginx-demo.name\" . }} spec: containers: - name: nginx image: \"{{ .Values.image.repository }}:{{ .Values.image.tag }}\" imagePullPolicy: {{ .Values.image.pullPolicy }} ports: - containerPort: 80 🔗 templates/service.yaml apiVersion: v1 kind: Service metadata: name: {{ include \"nginx-demo.fullname\" . }} labels: {{- include \"nginx-demo.labels\" . | nindent 4 }} spec: type: {{ .Values.service.type }} ports: - port: {{ .Values.service.port }} targetPort: 80 protocol: TCP name: http selector: app: {{ include \"nginx-demo.name\" . }} 🧠 templates/_helpers.tpl {{- define \"nginx-demo.name\" -}} nginx {{- end }} {{- define \"nginx-demo.fullname\" -}} {{ .Release.Name }}-nginx {{- end }} {{- define \"nginx-demo.labels\" -}} app.kubernetes.io/name: {{ include \"nginx-demo.name\" . }} helm.sh/chart: {{ .Chart.Name }}-{{ .Chart.Version }} app.kubernetes.io/instance: {{ .Release.Name }} app.kubernetes.io/managed-by: {{ .Release.Service }} {{- end }} 📝 templates/notes.txt NGINX has been deployed successfully! You can access it within the cluster using: kubectl port-forward svc/{{ include \"nginx-demo.fullname\" . }} 8080:{{ .Values.service.port }} Then open your browser at: http://localhost:8080/ ✅ templates/tests/test-connection.yaml apiVersion: v1 kind: Pod metadata: name: \"{{ include \"nginx-demo.fullname\" . }}-test\" labels: {{- include \"nginx-demo.labels\" . | nindent 4 }} annotations: \"helm.sh/hook\": test spec: containers: - name: wget image: busybox command: ['wget'] args: ['{{ include \"nginx-demo.fullname\" . }}:{{ .Values.service.port }}'] restartPolicy: Never 🚀 Deploy the Chart helm install my-nginx ./nginx-demo 🧪 Run Helm Tests helm test my-nginx This complete example gives you a production-grade Helm chart foundation for deploying NGINX, including best practices like helpers, notes, and tests.\nLet me know if you want to add Ingress, HPA, or configmap examples!",
    "description": "Please visit official doc helm charts development\n🧪 Example: Custom NGINX Helm Chart Structure Create a new Helm chart:\nhelm create nginx-demo cd nginx-demo Then modify or replace the following files:\n📁 Chart.yaml apiVersion: v2 name: nginx-demo description: A Helm chart for deploying NGINX type: application version: 0.1.0 appVersion: \"1.25.2\" 📄 values.yaml replicaCount: 2 image: repository: nginx pullPolicy: IfNotPresent tag: \"1.25.2\" service: type: ClusterIP port: 80 ingress: enabled: false resources: {} nodeSelector: {} tolerations: [] affinity: {} ⚙️ templates/deployment.yaml apiVersion: apps/v1 kind: Deployment metadata: name: {{ include \"nginx-demo.fullname\" . }} labels: {{- include \"nginx-demo.labels\" . | nindent 4 }} spec: replicas: {{ .Values.replicaCount }} selector: matchLabels: app: {{ include \"nginx-demo.name\" . }} template: metadata: labels: app: {{ include \"nginx-demo.name\" . }} spec: containers: - name: nginx image: \"{{ .Values.image.repository }}:{{ .Values.image.tag }}\" imagePullPolicy: {{ .Values.image.pullPolicy }} ports: - containerPort: 80 🔗 templates/service.yaml apiVersion: v1 kind: Service metadata: name: {{ include \"nginx-demo.fullname\" . }} labels: {{- include \"nginx-demo.labels\" . | nindent 4 }} spec: type: {{ .Values.service.type }} ports: - port: {{ .Values.service.port }} targetPort: 80 protocol: TCP name: http selector: app: {{ include \"nginx-demo.name\" . }} 🧠 templates/_helpers.tpl {{- define \"nginx-demo.name\" -}} nginx {{- end }} {{- define \"nginx-demo.fullname\" -}} {{ .Release.Name }}-nginx {{- end }} {{- define \"nginx-demo.labels\" -}} app.kubernetes.io/name: {{ include \"nginx-demo.name\" . }} helm.sh/chart: {{ .Chart.Name }}-{{ .Chart.Version }} app.kubernetes.io/instance: {{ .Release.Name }} app.kubernetes.io/managed-by: {{ .Release.Service }} {{- end }} 📝 templates/notes.txt NGINX has been deployed successfully! You can access it within the cluster using: kubectl port-forward svc/{{ include \"nginx-demo.fullname\" . }} 8080:{{ .Values.service.port }} Then open your browser at: http://localhost:8080/ ✅ templates/tests/test-connection.yaml apiVersion: v1 kind: Pod metadata: name: \"{{ include \"nginx-demo.fullname\" . }}-test\" labels: {{- include \"nginx-demo.labels\" . | nindent 4 }} annotations: \"helm.sh/hook\": test spec: containers: - name: wget image: busybox command: ['wget'] args: ['{{ include \"nginx-demo.fullname\" . }}:{{ .Values.service.port }}'] restartPolicy: Never 🚀 Deploy the Chart helm install my-nginx ./nginx-demo 🧪 Run Helm Tests helm test my-nginx This complete example gives you a production-grade Helm chart foundation for deploying NGINX, including best practices like helpers, notes, and tests.",
    "tags": [],
    "title": "Creating Helm Charts ",
    "uri": "/helm/04.helm/index.html"
  },
  {
    "breadcrumb": "",
    "content": "🎯 Objective Learn how to create, package, and host Helm charts for two microservices — Order and Delivery — in a GitHub-based Helm repository using busybox as a placeholder image.\n🔧 Prerequisites Helm installed on your local machine A configured Kubernetes cluster A GitHub account to host your Helm repository kubectl CLI configured for your cluster 🏗️ Step 1: Create the Helm Charts Set up project structure:\nmkdir -p helm-registry/{order,delivery} cd helm-registry Create Helm charts:\nhelm create order helm create delivery 🛠️ Step 2: Customize Helm Charts Shared Deployment Template apiVersion: apps/v1 kind: Deployment metadata: name: {{ .Release.Name }}-{{ .Chart.Name }} labels: app: {{ .Chart.Name }} spec: replicas: 1 selector: matchLabels: app: {{ .Chart.Name }} template: metadata: labels: app: {{ .Chart.Name }} spec: containers: - name: {{ .Chart.Name }} image: {{ .Values.image.repository }}:{{ .Values.image.tag }} command: ['sh', '-c', 'echo {{ .Values.appMessage }}; sleep 3600'] imagePullPolicy: {{ .Values.image.pullPolicy }} 🔧 Order Chart – values.yaml image: repository: busybox tag: latest pullPolicy: IfNotPresent appMessage: \"Order Service is running\" 🔧 Delivery Chart – values.yaml image: repository: busybox tag: latest pullPolicy: IfNotPresent appMessage: \"Delivery Service is running\" 📦 Step 3: Package the Helm Charts helm package order helm package delivery helm repo index . This will generate .tgz packages and an index.yaml file.\n🌐 Step 4: Host Your Repo on GitHub Create a GitHub repository (e.g., helm-registry)\nInitialize Git and push content:\ngit init git remote add origin https://github.com/\u003cyour-username\u003e/helm-registry.git git add . git commit -m \"Add Order and Delivery Helm charts\" git push -u origin main Enable GitHub Pages\nGo to Settings → Pages Choose the main branch as the source and save 🚀 Step 5: Use Your GitHub-hosted Helm Repo Add your custom Helm repo:\nhelm repo add teamcharts https://\u003cyour-username\u003e.github.io/helm-registry helm repo update Search for your charts:\nhelm search repo teamcharts Install a service:\nhelm install order-app teamcharts/order helm install delivery-app teamcharts/delivery ✅ With this setup, you now have a functional Helm chart repository hosted on GitHub — ideal for internal services, demos, or even production use cases.",
    "description": "🎯 Objective Learn how to create, package, and host Helm charts for two microservices — Order and Delivery — in a GitHub-based Helm repository using busybox as a placeholder image.\n🔧 Prerequisites Helm installed on your local machine A configured Kubernetes cluster A GitHub account to host your Helm repository kubectl CLI configured for your cluster 🏗️ Step 1: Create the Helm Charts Set up project structure:\nmkdir -p helm-registry/{order,delivery} cd helm-registry Create Helm charts:",
    "tags": [],
    "title": "Hosting Helm Charts on GitHub",
    "uri": "/helm/05.helm/index.html"
  },
  {
    "breadcrumb": "",
    "content": "🔍 Preview Manifests Before Installing To preview the rendered Kubernetes manifests from a Helm chart without installing it, use:\nhelm template \u003crelease-name\u003e \u003cchart-path-or-name\u003e Example: helm template my-nginx bitnami/nginx 🧪 Simulate Installation (Dry Run) To simulate an install with all validations (including custom values):\nhelm install \u003crelease-name\u003e \u003cchart-path-or-name\u003e --dry-run --debug Example: helm install my-nginx bitnami/nginx --dry-run --debug 📥 Get Values from Existing Release To retrieve the custom values used in an existing Helm release:\nhelm get values \u003crelease-name\u003e -n \u003cnamespace\u003e Example: helm get values my-nginx -n default To get all values including defaults and overrides (merged output):\nhelm get values \u003crelease-name\u003e -n \u003cnamespace\u003e --all Example: helm get values my-nginx -n default --all 📄 Get Default values.yaml from a Helm Chart To get the default values.yaml file from a Helm chart before installing it, use:\nhelm show values \u003cchart-name\u003e 📦 Example (from a remote repository): helm show values bitnami/nginx 📁 Example (from a local chart directory): helm show values ./mychart This command prints all the default configuration options supported by the chart.\n💾 Save Default Values for Customization You can redirect the output to a file, edit it, and use it during installation:\nhelm show values bitnami/nginx \u003e custom-values.yaml Then install with:\nhelm install my-nginx bitnami/nginx --values custom-values.yaml ✅ This is a best practice for controlled and repeatable deployments.\n🔧 Using -f, --values, and --set in Helm Helm allows customization of charts using:\n-f or --values to supply a YAML file with configuration overrides. --set to pass values inline via the command line. 📁 Using -f or --values (YAML file) helm install my-nginx bitnami/nginx -f custom-values.yaml helm upgrade my-nginx bitnami/nginx -f dev-values.yaml -n dev You can also supply multiple files in order of precedence:\nhelm install my-nginx bitnami/nginx -f base.yaml -f prod.yaml The last file overrides values from the previous ones.\n💡 Using --set (Inline values) Set a single value inline:\nhelm install my-nginx bitnami/nginx --set service.type=LoadBalancer Set multiple values inline:\nhelm install my-nginx bitnami/nginx \\ --set replicaCount=2 \\ --set image.tag=1.23.0 \\ --set service.type=NodePort 🔄 Combine --set and --values You can combine both options. Inline --set overrides the values in the file:\nhelm install my-nginx bitnami/nginx \\ -f custom-values.yaml \\ --set service.type=LoadBalancer 📝 Set Nested/Array Values with --set For nested keys:\nhelm install my-nginx bitnami/nginx \\ --set metrics.enabled=true \\ --set ingress.enabled=true \\ --set ingress.hostname=nginx.example.com ✅ Use --values for maintainable configurations,\n✅ Use --set for quick overrides or scripting.",
    "description": "🔍 Preview Manifests Before Installing To preview the rendered Kubernetes manifests from a Helm chart without installing it, use:\nhelm template \u003crelease-name\u003e \u003cchart-path-or-name\u003e Example: helm template my-nginx bitnami/nginx 🧪 Simulate Installation (Dry Run) To simulate an install with all validations (including custom values):\nhelm install \u003crelease-name\u003e \u003cchart-path-or-name\u003e --dry-run --debug Example: helm install my-nginx bitnami/nginx --dry-run --debug 📥 Get Values from Existing Release To retrieve the custom values used in an existing Helm release:",
    "tags": [],
    "title": "Additional",
    "uri": "/helm/additional/index.html"
  },
  {
    "breadcrumb": "",
    "content": "",
    "description": "",
    "tags": [],
    "title": "Categories",
    "uri": "/categories/index.html"
  },
  {
    "breadcrumb": "",
    "content": "",
    "description": "",
    "tags": [],
    "title": "Tags",
    "uri": "/tags/index.html"
  }
]
