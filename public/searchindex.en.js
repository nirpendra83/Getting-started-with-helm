var relearn_searchindex = [
  {
    "breadcrumb": "",
    "content": "📌 Introduction to Helm What is Helm? Why use Helm for Kubernetes application deployment? Key components: Charts, Repositories, Releases 📚 Exploring the Official Helm Documentation Navigating helm.sh/docs Installation and prerequisites Understanding the Helm CLI and commands Helm 3 vs Helm 2 (brief overview) 🧩 Working with Existing Helm Charts 🔍 Discovering and Using Helm Repositories Adding public and private chart repositories Searching for charts (helm search hub vs helm search repo) Repository management commands 🚀 Deploying a Helm Release Installing a chart as a release Setting a namespace for the deployment Dry run and debug before actual deployment ⚙️ Customizing Charts with Values Understanding values.yaml Overriding values using: Custom values.yaml files --set CLI option --set-file and --set-string 🔁 Managing Helm Releases Upgrading a release with updated values or chart versions Rolling back to a previous release version Viewing and diffing historical release versions Uninstalling a release cleanly 🌐 Multi-Environment Helm Usage Structuring values for different environments (dev, staging, prod) Folder-based environment separation Using --values with multiple files for environment-specific configs 🛠️ Creating Your Own Helm Charts ⚡ Helm Chart Quick Start helm create mychart Directory structure explained Modifying the default template 🧬 Helm Template Engine and Syntax How Helm renders templates Using {{ .Values }}, {{ .Chart }}, {{ .Release }} objects 🏗 Built-in Objects and Functions Overview of available Helm objects Useful template functions (include, required, lookup, toYaml, etc.) Best practices in chart templating 🧪 Testing and Validating Charts helm lint and template validation Using helm template for local rendering Unit testing templates with tools like helm-unittest 🧰 Troubleshooting and Tips Debugging with --debug and --dry-run Common errors and how to fix them Checking logs and Helm release history Understanding exit codes and command output",
    "description": "📌 Introduction to Helm What is Helm? Why use Helm for Kubernetes application deployment? Key components: Charts, Repositories, Releases 📚 Exploring the Official Helm Documentation Navigating helm.sh/docs Installation and prerequisites Understanding the Helm CLI and commands Helm 3 vs Helm 2 (brief overview) 🧩 Working with Existing Helm Charts 🔍 Discovering and Using Helm Repositories Adding public and private chart repositories Searching for charts (helm search hub vs helm search repo) Repository management commands 🚀 Deploying a Helm Release Installing a chart as a release Setting a namespace for the deployment Dry run and debug before actual deployment ⚙️ Customizing Charts with Values Understanding values.yaml Overriding values using: Custom values.yaml files --set CLI option --set-file and --set-string 🔁 Managing Helm Releases Upgrading a release with updated values or chart versions Rolling back to a previous release version Viewing and diffing historical release versions Uninstalling a release cleanly 🌐 Multi-Environment Helm Usage Structuring values for different environments (dev, staging, prod) Folder-based environment separation Using --values with multiple files for environment-specific configs 🛠️ Creating Your Own Helm Charts ⚡ Helm Chart Quick Start helm create mychart Directory structure explained Modifying the default template 🧬 Helm Template Engine and Syntax How Helm renders templates Using {{ .Values }}, {{ .Chart }}, {{ .Release }} objects 🏗 Built-in Objects and Functions Overview of available Helm objects Useful template functions (include, required, lookup, toYaml, etc.) Best practices in chart templating 🧪 Testing and Validating Charts helm lint and template validation Using helm template for local rendering Unit testing templates with tools like helm-unittest 🧰 Troubleshooting and Tips Debugging with --debug and --dry-run Common errors and how to fix them Checking logs and Helm release history Understanding exit codes and command output",
    "tags": [],
    "title": "Helm Contents",
    "uri": "/helm/toc/index.html"
  },
  {
    "breadcrumb": "",
    "content": "Table of Contents 📌 Introduction to Helm What is Helm? Why use Helm for Kubernetes application deployment? Key components: Charts, Repositories, Releases 📚 Exploring the Official Helm Documentation Navigating helm.sh/docs Installation and prerequisites Understanding the Helm CLI and commands Helm 3 vs Helm 2 (brief overview) 🧩 Working with Existing Helm Charts 🔍 Discovering and Using Helm Repositories Adding public and private chart repositories Searching for charts (helm search hub vs helm search repo) Repository management commands 🚀 Deploying a Helm Release Installing a chart as a release Setting a namespace for the deployment Dry run and debug before actual deployment ⚙️ Customizing Charts with Values Understanding values.yaml Overriding values using: Custom values.yaml files --set CLI option --set-file and --set-string 🔁 Managing Helm Releases Upgrading a release with updated values or chart versions Rolling back to a previous release version Viewing and diffing historical release versions Uninstalling a release cleanly 🌐 Multi-Environment Helm Usage Structuring values for different environments (dev, staging, prod) Folder-based environment separation Using --values with multiple files for environment-specific configs 🛠️ Creating Your Own Helm Charts ⚡ Helm Chart Quick Start helm create mychart Directory structure explained Modifying the default template 🧬 Helm Template Engine and Syntax How Helm renders templates Using {{ .Values }}, {{ .Chart }}, {{ .Release }} objects 🏗 Built-in Objects and Functions Overview of available Helm objects Useful template functions (include, required, lookup, toYaml, etc.) Best practices in chart templating 🧪 Testing and Validating Charts helm lint and template validation Using helm template for local rendering Unit testing templates with tools like helm-unittest 🧰 Troubleshooting and Tips Debugging with --debug and --dry-run Common errors and how to fix them Checking logs and Helm release history Understanding exit codes and command output",
    "description": "Table of Contents 📌 Introduction to Helm What is Helm? Why use Helm for Kubernetes application deployment? Key components: Charts, Repositories, Releases 📚 Exploring the Official Helm Documentation Navigating helm.sh/docs Installation and prerequisites Understanding the Helm CLI and commands Helm 3 vs Helm 2 (brief overview) 🧩 Working with Existing Helm Charts 🔍 Discovering and Using Helm Repositories Adding public and private chart repositories Searching for charts (helm search hub vs helm search repo) Repository management commands 🚀 Deploying a Helm Release Installing a chart as a release Setting a namespace for the deployment Dry run and debug before actual deployment ⚙️ Customizing Charts with Values Understanding values.yaml Overriding values using: Custom values.yaml files --set CLI option --set-file and --set-string 🔁 Managing Helm Releases Upgrading a release with updated values or chart versions Rolling back to a previous release version Viewing and diffing historical release versions Uninstalling a release cleanly 🌐 Multi-Environment Helm Usage Structuring values for different environments (dev, staging, prod) Folder-based environment separation Using --values with multiple files for environment-specific configs 🛠️ Creating Your Own Helm Charts ⚡ Helm Chart Quick Start helm create mychart Directory structure explained Modifying the default template 🧬 Helm Template Engine and Syntax How Helm renders templates Using {{ .Values }}, {{ .Chart }}, {{ .Release }} objects 🏗 Built-in Objects and Functions Overview of available Helm objects Useful template functions (include, required, lookup, toYaml, etc.) Best practices in chart templating 🧪 Testing and Validating Charts helm lint and template validation Using helm template for local rendering Unit testing templates with tools like helm-unittest 🧰 Troubleshooting and Tips Debugging with --debug and --dry-run Common errors and how to fix them Checking logs and Helm release history Understanding exit codes and command output",
    "tags": [],
    "title": "Helm Table of Contents",
    "uri": "/toc/index.html"
  },
  {
    "breadcrumb": "Vmwares",
    "content": "🧠 VMware Concepts: DRS vs HA, vMotion vs sMotion This document outlines the differences between VMware DRS, HA, vMotion, and Storage vMotion, which are key features of vSphere for availability, load balancing, and live migration.\n🔀 DRS (Distributed Resource Scheduler) Feature Description Purpose Automatically balances workloads across hosts based on CPU/RAM usage Type Load balancing and resource management Requires vCenter, shared storage, vMotion enabled Use Case Avoid resource contention, optimize performance ✅ Example: VM is consuming high CPU on Host A → DRS moves it to Host B (less loaded) using vMotion. ⚡ HA (High Availability) Feature Description Purpose Restarts VMs on other hosts if a host fails Type Availability and failover mechanism Requires vCenter, shared storage (for VM files), ESXi hosts in cluster Use Case Minimize downtime from host hardware failure ✅ Example: Host A fails → HA restarts its VMs automatically on Host B. 🔄 vMotion Feature Description Purpose Live migrate a running VM from one ESXi host to another without downtime Migrates VM’s memory and CPU state, not disk Requires Shared storage (e.g., NFS, iSCSI, VMFS) and vMotion network Use Case Maintenance, Load Balancing (via DRS), zero-downtime migration ✅ Example: Move a VM from Host A to Host B while it’s running, with no downtime. 💽 Storage vMotion (sMotion) Feature Description Purpose Move a VM’s virtual disk files (VMDKs) between datastores, live Migrates Only storage, not the compute/CPU/memory Requires Datastores accessible to the host Use Case Balance storage, move to faster/larger datastore, maintenance of old storage ✅ Example: VM stays on Host A, but its VMDK is moved from Datastore1 to Datastore2. 🧩 Summary Table Feature Function What It Moves Downtime? Use Case DRS Load balancing VMs between hosts (uses vMotion) ❌ No Optimize performance HA Failover recovery Restarts VMs ✅ Brief Host failure recovery vMotion Live VM migration Memory \u0026 CPU state ❌ No Zero-downtime maintenance Storage vMotion Live storage migration VMDK files ❌ No Migrate to better/faster storage 📝 Notes vMotion and sMotion can be combined to move both compute and storage (called Enhanced vMotion). DRS uses vMotion under the hood to move VMs. HA is reactive (after failure), DRS is proactive (performance/load-based). ✅ These features are essential for maintaining high availability, flexibility, and performance in VMware environments.",
    "description": "🧠 VMware Concepts: DRS vs HA, vMotion vs sMotion This document outlines the differences between VMware DRS, HA, vMotion, and Storage vMotion, which are key features of vSphere for availability, load balancing, and live migration.\n🔀 DRS (Distributed Resource Scheduler) Feature Description Purpose Automatically balances workloads across hosts based on CPU/RAM usage Type Load balancing and resource management Requires vCenter, shared storage, vMotion enabled Use Case Avoid resource contention, optimize performance ✅ Example: VM is consuming high CPU on Host A → DRS moves it to Host B (less loaded) using vMotion. ⚡ HA (High Availability) Feature Description Purpose Restarts VMs on other hosts if a host fails Type Availability and failover mechanism Requires vCenter, shared storage (for VM files), ESXi hosts in cluster Use Case Minimize downtime from host hardware failure ✅ Example: Host A fails → HA restarts its VMs automatically on Host B. 🔄 vMotion Feature Description Purpose Live migrate a running VM from one ESXi host to another without downtime Migrates VM’s memory and CPU state, not disk Requires Shared storage (e.g., NFS, iSCSI, VMFS) and vMotion network Use Case Maintenance, Load Balancing (via DRS), zero-downtime migration ✅ Example: Move a VM from Host A to Host B while it’s running, with no downtime. 💽 Storage vMotion (sMotion) Feature Description Purpose Move a VM’s virtual disk files (VMDKs) between datastores, live Migrates Only storage, not the compute/CPU/memory Requires Datastores accessible to the host Use Case Balance storage, move to faster/larger datastore, maintenance of old storage ✅ Example: VM stays on Host A, but its VMDK is moved from Datastore1 to Datastore2. 🧩 Summary Table Feature Function What It Moves Downtime? Use Case DRS Load balancing VMs between hosts (uses vMotion) ❌ No Optimize performance HA Failover recovery Restarts VMs ✅ Brief Host failure recovery vMotion Live VM migration Memory \u0026 CPU state ❌ No Zero-downtime maintenance Storage vMotion Live storage migration VMDK files ❌ No Migrate to better/faster storage 📝 Notes vMotion and sMotion can be combined to move both compute and storage (called Enhanced vMotion). DRS uses vMotion under the hood to move VMs. HA is reactive (after failure), DRS is proactive (performance/load-based). ✅ These features are essential for maintaining high availability, flexibility, and performance in VMware environments.",
    "tags": [],
    "title": "VMware DRS vs HA, vMotion vs Storage vMotion",
    "uri": "/vmware/vmware01/index.html"
  },
  {
    "breadcrumb": "",
    "content": "📦 What is Helm? Helm is a package manager for Kubernetes that helps you define, install, and manage applications in your Kubernetes clusters.\nIt simplifies the deployment process by using reusable, shareable packages called charts — which bundle together YAML configurations for Kubernetes resources.\nHelm makes it easy to install and manage apps on Kubernetes. Instead of writing many config files, Helm bundles them so you can install apps with just one command. It helps you upgrade or roll back apps easily if something goes wrong. You can customize apps by changing simple settings instead of editing complex files. Helm has lots of ready-made app packages (called charts) that you can use and share. It keeps track of what you installed, so managing your apps is simpler. 🧰 Helm: APT or YUM for Kubernetes Just like APT on Debian-based systems or YUM on Red Hat-based systems manages Linux packages, Helm manages Kubernetes applications.\n💡 How It Works On Linux: You install NGINX using APT:\nsudo apt install nginx On Kubernetes with Helm: You install NGINX using a Helm chart:\nAdd Helm repo first\nhelm repo add bitnami https://charts.bitnami.com/bitnami Update the repo\nhelm repo update Install Nginx Application (package)\nhelm install my-nginx bitnami/nginx This command pulls a chart from a repository, creates the necessary Kubernetes resources, and deploys the application in your cluster.\n🚀 Why Use Helm? 1. 📦 Package Management Helm charts are similar to .deb or .rpm packages — they package everything needed for an application, including deployments, services, config maps, and secrets.\n2. 🕒 Version Control You can install specific versions of applications, just like with package managers:\nhelm install my-nginx bitnami/nginx --version 13.0.0 This makes upgrades and rollbacks safe and predictable.\n3. ⚙️ Configuration Management Override default settings using values files:\nhelm install my-nginx bitnami/nginx --values custom-values.yaml Or via the command line:\nhelm install my-nginx bitnami/nginx --set service.type=NodePort This makes deployments flexible and environment-specific.\n4. 🔗 Dependency Management Helm handles dependencies between components, ensuring that services like databases are deployed and ready before dependent apps are installed — just like APT resolves software dependencies.\n🧠 Why Helm Is Essential Kubernetes involves managing multiple YAML files for services, deployments, config maps, secrets, and more. Helm bundles all these into a single chart that can be versioned, shared, and deployed with one command. This approach brings consistency, reusability, and efficiency to Kubernetes application lifecycle management.\nHelm is widely adopted in CI/CD pipelines, GitOps workflows, and is considered a standard for Kubernetes package management.",
    "description": "📦 What is Helm? Helm is a package manager for Kubernetes that helps you define, install, and manage applications in your Kubernetes clusters.\nIt simplifies the deployment process by using reusable, shareable packages called charts — which bundle together YAML configurations for Kubernetes resources.\nHelm makes it easy to install and manage apps on Kubernetes. Instead of writing many config files, Helm bundles them so you can install apps with just one command. It helps you upgrade or roll back apps easily if something goes wrong. You can customize apps by changing simple settings instead of editing complex files. Helm has lots of ready-made app packages (called charts) that you can use and share. It keeps track of what you installed, so managing your apps is simpler. 🧰 Helm: APT or YUM for Kubernetes Just like APT on Debian-based systems or YUM on Red Hat-based systems manages Linux packages, Helm manages Kubernetes applications.",
    "tags": [],
    "title": "What is Helm?",
    "uri": "/01.helm/index.html"
  },
  {
    "breadcrumb": "",
    "content": "📦 What is Helm? Helm is a package manager for Kubernetes that helps you define, install, and manage applications in your Kubernetes clusters.\nIt simplifies the deployment process by using reusable, shareable packages called charts — which bundle together YAML configurations for Kubernetes resources.\nHelm makes it easy to install and manage apps on Kubernetes. Instead of writing many config files, Helm bundles them so you can install apps with just one command. It helps you upgrade or roll back apps easily if something goes wrong. You can customize apps by changing simple settings instead of editing complex files. Helm has lots of ready-made app packages (called charts) that you can use and share. It keeps track of what you installed, so managing your apps is simpler. 🧰 Helm: APT or YUM for Kubernetes Just like APT on Debian-based systems or YUM on Red Hat-based systems manages Linux packages, Helm manages Kubernetes applications.\n💡 How It Works On Linux: You install NGINX using APT:\nsudo apt install nginx On Kubernetes with Helm: You install NGINX using a Helm chart:\nAdd Helm repo first\nhelm repo add bitnami https://charts.bitnami.com/bitnami Update the repo\nhelm repo update Install Nginx Application (package)\nhelm install my-nginx bitnami/nginx This command pulls a chart from a repository, creates the necessary Kubernetes resources, and deploys the application in your cluster.\n🚀 Why Use Helm? 1. 📦 Package Management Helm charts are similar to .deb or .rpm packages — they package everything needed for an application, including deployments, services, config maps, and secrets.\n2. 🕒 Version Control You can install specific versions of applications, just like with package managers:\nhelm install my-nginx bitnami/nginx --version 13.0.0 This makes upgrades and rollbacks safe and predictable.\n3. ⚙️ Configuration Management Override default settings using values files:\nhelm install my-nginx bitnami/nginx --values custom-values.yaml Or via the command line:\nhelm install my-nginx bitnami/nginx --set service.type=NodePort This makes deployments flexible and environment-specific.\n4. 🔗 Dependency Management Helm handles dependencies between components, ensuring that services like databases are deployed and ready before dependent apps are installed — just like APT resolves software dependencies.\n🧠 Why Helm Is Essential Kubernetes involves managing multiple YAML files for services, deployments, config maps, secrets, and more. Helm bundles all these into a single chart that can be versioned, shared, and deployed with one command. This approach brings consistency, reusability, and efficiency to Kubernetes application lifecycle management.\nHelm is widely adopted in CI/CD pipelines, GitOps workflows, and is considered a standard for Kubernetes package management.",
    "description": "📦 What is Helm? Helm is a package manager for Kubernetes that helps you define, install, and manage applications in your Kubernetes clusters.\nIt simplifies the deployment process by using reusable, shareable packages called charts — which bundle together YAML configurations for Kubernetes resources.\nHelm makes it easy to install and manage apps on Kubernetes. Instead of writing many config files, Helm bundles them so you can install apps with just one command. It helps you upgrade or roll back apps easily if something goes wrong. You can customize apps by changing simple settings instead of editing complex files. Helm has lots of ready-made app packages (called charts) that you can use and share. It keeps track of what you installed, so managing your apps is simpler. 🧰 Helm: APT or YUM for Kubernetes Just like APT on Debian-based systems or YUM on Red Hat-based systems manages Linux packages, Helm manages Kubernetes applications.",
    "tags": [],
    "title": "What is Helm?",
    "uri": "/helm/01.helm/index.html"
  },
  {
    "breadcrumb": "",
    "content": "Helm Chart Helm Repository Helm CLI Helm Release 🧱 Helm Charts A Helm chart is a packaged collection of Kubernetes resource definitions required to deploy applications. Think of it like a .deb or .rpm package in Linux — reusable, shareable, and version-controlled.\n📦 Chart Structure mychart/ ├── Chart.yaml # Metadata about the chart (name, version, description) ├── values.yaml # Default config values for templates ├── charts/ # Optional: subcharts (dependencies) ├── templates/ # Kubernetes manifest templates │ ├── deployment.yaml │ ├── service.yaml │ ├── _helpers.tpl # Reusable template snippets │ └── ... └── README.md # Optional: chart documentation 📄 Key Files Chart.yaml – Metadata about the chart (name, version, description) values.yaml – Default configuration values; can be overridden at install/upgrade templates/ – Kubernetes manifests rendered with Go templating charts/ – Subcharts or dependencies README.md – Optional documentation 🛠️ Create a New Chart helm create myapp This generates a scaffolded chart directory under myapp/.\n🚀 Install a Chart helm install my-nginx bitnami/nginx 📚 Helm Repositories A Helm repository is a remote or local source that hosts one or more Helm charts, similar to APT/YUM repos in Linux.\n➕ Add a Repository helm repo add bitnami https://charts.bitnami.com/bitnami 📋 List Configured Repositories helm repo list 🔄 Update Repository Cache helm repo update Repositories enable you to distribute and manage versioned charts in a structured manner.\n🚢 Helm Releases A Helm release is a deployed instance of a chart in your Kubernetes cluster. Each release is uniquely named and tracks the chart version, configuration values, and revision history.\n🚀 Install / Create a Release helm install myapp ./myapp 📜 List All Releases helm list 🔧 Upgrade a Release helm upgrade myapp ./myapp ⏪ Roll Back to a Previous Revision helm rollback myapp 1 ❌ Delete a Release helm uninstall myapp Releases provide full control over versioning, rollback, and lifecycle management of your Kubernetes apps.\n🧰 Common Helm CLI Commands # Add a repository helm repo add \u003cname\u003e \u003curl\u003e # Update repository cache helm repo update # Search for a chart helm search repo \u003ckeyword\u003e # Install a chart helm install \u003crelease-name\u003e \u003cchart-name\u003e # List installed releases helm list # Upgrade a release helm upgrade \u003crelease-name\u003e \u003cchart-name\u003e # Roll back a release helm rollback \u003crelease-name\u003e \u003crevision-number\u003e # Uninstall a release helm uninstall \u003crelease-name\u003e 🧠 Summary Helm Charts: Packaged applications with templated Kubernetes manifests. Helm Repositories: Storage locations for Helm charts (public or private). Helm Releases: Deployed and versioned instances of a chart within a cluster. Helm CLI: Command-line interface for managing charts, releases, and repos. Helm streamlines application deployment on Kubernetes by bringing structure, reusability, and lifecycle control to complex workloads.",
    "description": "Helm Chart Helm Repository Helm CLI Helm Release 🧱 Helm Charts A Helm chart is a packaged collection of Kubernetes resource definitions required to deploy applications. Think of it like a .deb or .rpm package in Linux — reusable, shareable, and version-controlled.\n📦 Chart Structure mychart/ ├── Chart.yaml # Metadata about the chart (name, version, description) ├── values.yaml # Default config values for templates ├── charts/ # Optional: subcharts (dependencies) ├── templates/ # Kubernetes manifest templates │ ├── deployment.yaml │ ├── service.yaml │ ├── _helpers.tpl # Reusable template snippets │ └── ... └── README.md # Optional: chart documentation 📄 Key Files Chart.yaml – Metadata about the chart (name, version, description) values.yaml – Default configuration values; can be overridden at install/upgrade templates/ – Kubernetes manifests rendered with Go templating charts/ – Subcharts or dependencies README.md – Optional documentation 🛠️ Create a New Chart helm create myapp This generates a scaffolded chart directory under myapp/.",
    "tags": [],
    "title": "Helm Components",
    "uri": "/03-helm/index.html"
  },
  {
    "breadcrumb": "",
    "content": "Helm Chart Helm Repository Helm CLI Helm Release 🧱 Helm Charts A Helm chart is a packaged collection of Kubernetes resource definitions required to deploy applications. Think of it like a .deb or .rpm package in Linux — reusable, shareable, and version-controlled.\n📦 Chart Structure mychart/ ├── Chart.yaml # Metadata about the chart (name, version, description) ├── values.yaml # Default config values for templates ├── charts/ # Optional: subcharts (dependencies) ├── templates/ # Kubernetes manifest templates │ ├── deployment.yaml │ ├── service.yaml │ ├── _helpers.tpl # Reusable template snippets │ └── ... └── README.md # Optional: chart documentation 📄 Key Files Chart.yaml – Metadata about the chart (name, version, description) values.yaml – Default configuration values; can be overridden at install/upgrade templates/ – Kubernetes manifests rendered with Go templating charts/ – Subcharts or dependencies README.md – Optional documentation 🛠️ Create a New Chart helm create myapp This generates a scaffolded chart directory under myapp/.\n🚀 Install a Chart helm install my-nginx bitnami/nginx 📚 Helm Repositories A Helm repository is a remote or local source that hosts one or more Helm charts, similar to APT/YUM repos in Linux.\n➕ Add a Repository helm repo add bitnami https://charts.bitnami.com/bitnami 📋 List Configured Repositories helm repo list 🔄 Update Repository Cache helm repo update Repositories enable you to distribute and manage versioned charts in a structured manner.\n🚢 Helm Releases A Helm release is a deployed instance of a chart in your Kubernetes cluster. Each release is uniquely named and tracks the chart version, configuration values, and revision history.\n🚀 Install / Create a Release helm install myapp ./myapp 📜 List All Releases helm list 🔧 Upgrade a Release helm upgrade myapp ./myapp ⏪ Roll Back to a Previous Revision helm rollback myapp 1 ❌ Delete a Release helm uninstall myapp Releases provide full control over versioning, rollback, and lifecycle management of your Kubernetes apps.\n🧰 Common Helm CLI Commands # Add a repository helm repo add \u003cname\u003e \u003curl\u003e # Update repository cache helm repo update # Search for a chart helm search repo \u003ckeyword\u003e # Install a chart helm install \u003crelease-name\u003e \u003cchart-name\u003e # List installed releases helm list # Upgrade a release helm upgrade \u003crelease-name\u003e \u003cchart-name\u003e # Roll back a release helm rollback \u003crelease-name\u003e \u003crevision-number\u003e # Uninstall a release helm uninstall \u003crelease-name\u003e 🧠 Summary Helm Charts: Packaged applications with templated Kubernetes manifests. Helm Repositories: Storage locations for Helm charts (public or private). Helm Releases: Deployed and versioned instances of a chart within a cluster. Helm CLI: Command-line interface for managing charts, releases, and repos. Helm streamlines application deployment on Kubernetes by bringing structure, reusability, and lifecycle control to complex workloads.",
    "description": "Helm Chart Helm Repository Helm CLI Helm Release 🧱 Helm Charts A Helm chart is a packaged collection of Kubernetes resource definitions required to deploy applications. Think of it like a .deb or .rpm package in Linux — reusable, shareable, and version-controlled.\n📦 Chart Structure mychart/ ├── Chart.yaml # Metadata about the chart (name, version, description) ├── values.yaml # Default config values for templates ├── charts/ # Optional: subcharts (dependencies) ├── templates/ # Kubernetes manifest templates │ ├── deployment.yaml │ ├── service.yaml │ ├── _helpers.tpl # Reusable template snippets │ └── ... └── README.md # Optional: chart documentation 📄 Key Files Chart.yaml – Metadata about the chart (name, version, description) values.yaml – Default configuration values; can be overridden at install/upgrade templates/ – Kubernetes manifests rendered with Go templating charts/ – Subcharts or dependencies README.md – Optional documentation 🛠️ Create a New Chart helm create myapp This generates a scaffolded chart directory under myapp/.",
    "tags": [],
    "title": "Helm Components",
    "uri": "/helm/03-helm/index.html"
  },
  {
    "breadcrumb": "",
    "content": "Please visit official doc helm charts development\n🧪 Example: Custom NGINX Helm Chart Structure Create a new Helm chart:\nhelm create nginx-demo cd nginx-demo Then modify or replace the following files:\n📁 Chart.yaml apiVersion: v2 name: nginx-demo description: A Helm chart for deploying NGINX type: application version: 0.1.0 appVersion: \"1.25.2\" 📄 values.yaml replicaCount: 2 image: repository: nginx pullPolicy: IfNotPresent tag: \"1.25.2\" service: type: ClusterIP port: 80 ingress: enabled: false resources: {} nodeSelector: {} tolerations: [] affinity: {} ⚙️ templates/deployment.yaml apiVersion: apps/v1 kind: Deployment metadata: name: {{ include \"nginx-demo.fullname\" . }} labels: {{- include \"nginx-demo.labels\" . | nindent 4 }} spec: replicas: {{ .Values.replicaCount }} selector: matchLabels: app: {{ include \"nginx-demo.name\" . }} template: metadata: labels: app: {{ include \"nginx-demo.name\" . }} spec: containers: - name: nginx image: \"{{ .Values.image.repository }}:{{ .Values.image.tag }}\" imagePullPolicy: {{ .Values.image.pullPolicy }} ports: - containerPort: 80 🔗 templates/service.yaml apiVersion: v1 kind: Service metadata: name: {{ include \"nginx-demo.fullname\" . }} labels: {{- include \"nginx-demo.labels\" . | nindent 4 }} spec: type: {{ .Values.service.type }} ports: - port: {{ .Values.service.port }} targetPort: 80 protocol: TCP name: http selector: app: {{ include \"nginx-demo.name\" . }} 🧠 templates/_helpers.tpl {{- define \"nginx-demo.name\" -}} nginx {{- end }} {{- define \"nginx-demo.fullname\" -}} {{ .Release.Name }}-nginx {{- end }} {{- define \"nginx-demo.labels\" -}} app.kubernetes.io/name: {{ include \"nginx-demo.name\" . }} helm.sh/chart: {{ .Chart.Name }}-{{ .Chart.Version }} app.kubernetes.io/instance: {{ .Release.Name }} app.kubernetes.io/managed-by: {{ .Release.Service }} {{- end }} 📝 templates/notes.txt NGINX has been deployed successfully! You can access it within the cluster using: kubectl port-forward svc/{{ include \"nginx-demo.fullname\" . }} 8080:{{ .Values.service.port }} Then open your browser at: http://localhost:8080/ ✅ templates/tests/test-connection.yaml apiVersion: v1 kind: Pod metadata: name: \"{{ include \"nginx-demo.fullname\" . }}-test\" labels: {{- include \"nginx-demo.labels\" . | nindent 4 }} annotations: \"helm.sh/hook\": test spec: containers: - name: wget image: busybox command: ['wget'] args: ['{{ include \"nginx-demo.fullname\" . }}:{{ .Values.service.port }}'] restartPolicy: Never 🚀 Deploy the Chart helm install my-nginx ./nginx-demo 🧪 Run Helm Tests helm test my-nginx This complete example gives you a production-grade Helm chart foundation for deploying NGINX, including best practices like helpers, notes, and tests.\nLet me know if you want to add Ingress, HPA, or configmap examples!",
    "description": "Please visit official doc helm charts development\n🧪 Example: Custom NGINX Helm Chart Structure Create a new Helm chart:\nhelm create nginx-demo cd nginx-demo Then modify or replace the following files:\n📁 Chart.yaml apiVersion: v2 name: nginx-demo description: A Helm chart for deploying NGINX type: application version: 0.1.0 appVersion: \"1.25.2\" 📄 values.yaml replicaCount: 2 image: repository: nginx pullPolicy: IfNotPresent tag: \"1.25.2\" service: type: ClusterIP port: 80 ingress: enabled: false resources: {} nodeSelector: {} tolerations: [] affinity: {} ⚙️ templates/deployment.yaml apiVersion: apps/v1 kind: Deployment metadata: name: {{ include \"nginx-demo.fullname\" . }} labels: {{- include \"nginx-demo.labels\" . | nindent 4 }} spec: replicas: {{ .Values.replicaCount }} selector: matchLabels: app: {{ include \"nginx-demo.name\" . }} template: metadata: labels: app: {{ include \"nginx-demo.name\" . }} spec: containers: - name: nginx image: \"{{ .Values.image.repository }}:{{ .Values.image.tag }}\" imagePullPolicy: {{ .Values.image.pullPolicy }} ports: - containerPort: 80 🔗 templates/service.yaml apiVersion: v1 kind: Service metadata: name: {{ include \"nginx-demo.fullname\" . }} labels: {{- include \"nginx-demo.labels\" . | nindent 4 }} spec: type: {{ .Values.service.type }} ports: - port: {{ .Values.service.port }} targetPort: 80 protocol: TCP name: http selector: app: {{ include \"nginx-demo.name\" . }} 🧠 templates/_helpers.tpl {{- define \"nginx-demo.name\" -}} nginx {{- end }} {{- define \"nginx-demo.fullname\" -}} {{ .Release.Name }}-nginx {{- end }} {{- define \"nginx-demo.labels\" -}} app.kubernetes.io/name: {{ include \"nginx-demo.name\" . }} helm.sh/chart: {{ .Chart.Name }}-{{ .Chart.Version }} app.kubernetes.io/instance: {{ .Release.Name }} app.kubernetes.io/managed-by: {{ .Release.Service }} {{- end }} 📝 templates/notes.txt NGINX has been deployed successfully! You can access it within the cluster using: kubectl port-forward svc/{{ include \"nginx-demo.fullname\" . }} 8080:{{ .Values.service.port }} Then open your browser at: http://localhost:8080/ ✅ templates/tests/test-connection.yaml apiVersion: v1 kind: Pod metadata: name: \"{{ include \"nginx-demo.fullname\" . }}-test\" labels: {{- include \"nginx-demo.labels\" . | nindent 4 }} annotations: \"helm.sh/hook\": test spec: containers: - name: wget image: busybox command: ['wget'] args: ['{{ include \"nginx-demo.fullname\" . }}:{{ .Values.service.port }}'] restartPolicy: Never 🚀 Deploy the Chart helm install my-nginx ./nginx-demo 🧪 Run Helm Tests helm test my-nginx This complete example gives you a production-grade Helm chart foundation for deploying NGINX, including best practices like helpers, notes, and tests.",
    "tags": [],
    "title": "Creating Helm Charts ",
    "uri": "/04.helm/index.html"
  },
  {
    "breadcrumb": "",
    "content": "Please visit official doc helm charts development\n🧪 Example: Custom NGINX Helm Chart Structure Create a new Helm chart:\nhelm create nginx-demo cd nginx-demo Then modify or replace the following files:\n📁 Chart.yaml apiVersion: v2 name: nginx-demo description: A Helm chart for deploying NGINX type: application version: 0.1.0 appVersion: \"1.25.2\" 📄 values.yaml replicaCount: 2 image: repository: nginx pullPolicy: IfNotPresent tag: \"1.25.2\" service: type: ClusterIP port: 80 ingress: enabled: false resources: {} nodeSelector: {} tolerations: [] affinity: {} ⚙️ templates/deployment.yaml apiVersion: apps/v1 kind: Deployment metadata: name: {{ include \"nginx-demo.fullname\" . }} labels: {{- include \"nginx-demo.labels\" . | nindent 4 }} spec: replicas: {{ .Values.replicaCount }} selector: matchLabels: app: {{ include \"nginx-demo.name\" . }} template: metadata: labels: app: {{ include \"nginx-demo.name\" . }} spec: containers: - name: nginx image: \"{{ .Values.image.repository }}:{{ .Values.image.tag }}\" imagePullPolicy: {{ .Values.image.pullPolicy }} ports: - containerPort: 80 🔗 templates/service.yaml apiVersion: v1 kind: Service metadata: name: {{ include \"nginx-demo.fullname\" . }} labels: {{- include \"nginx-demo.labels\" . | nindent 4 }} spec: type: {{ .Values.service.type }} ports: - port: {{ .Values.service.port }} targetPort: 80 protocol: TCP name: http selector: app: {{ include \"nginx-demo.name\" . }} 🧠 templates/_helpers.tpl {{- define \"nginx-demo.name\" -}} nginx {{- end }} {{- define \"nginx-demo.fullname\" -}} {{ .Release.Name }}-nginx {{- end }} {{- define \"nginx-demo.labels\" -}} app.kubernetes.io/name: {{ include \"nginx-demo.name\" . }} helm.sh/chart: {{ .Chart.Name }}-{{ .Chart.Version }} app.kubernetes.io/instance: {{ .Release.Name }} app.kubernetes.io/managed-by: {{ .Release.Service }} {{- end }} 📝 templates/notes.txt NGINX has been deployed successfully! You can access it within the cluster using: kubectl port-forward svc/{{ include \"nginx-demo.fullname\" . }} 8080:{{ .Values.service.port }} Then open your browser at: http://localhost:8080/ ✅ templates/tests/test-connection.yaml apiVersion: v1 kind: Pod metadata: name: \"{{ include \"nginx-demo.fullname\" . }}-test\" labels: {{- include \"nginx-demo.labels\" . | nindent 4 }} annotations: \"helm.sh/hook\": test spec: containers: - name: wget image: busybox command: ['wget'] args: ['{{ include \"nginx-demo.fullname\" . }}:{{ .Values.service.port }}'] restartPolicy: Never 🚀 Deploy the Chart helm install my-nginx ./nginx-demo 🧪 Run Helm Tests helm test my-nginx This complete example gives you a production-grade Helm chart foundation for deploying NGINX, including best practices like helpers, notes, and tests.\nLet me know if you want to add Ingress, HPA, or configmap examples!",
    "description": "Please visit official doc helm charts development\n🧪 Example: Custom NGINX Helm Chart Structure Create a new Helm chart:\nhelm create nginx-demo cd nginx-demo Then modify or replace the following files:\n📁 Chart.yaml apiVersion: v2 name: nginx-demo description: A Helm chart for deploying NGINX type: application version: 0.1.0 appVersion: \"1.25.2\" 📄 values.yaml replicaCount: 2 image: repository: nginx pullPolicy: IfNotPresent tag: \"1.25.2\" service: type: ClusterIP port: 80 ingress: enabled: false resources: {} nodeSelector: {} tolerations: [] affinity: {} ⚙️ templates/deployment.yaml apiVersion: apps/v1 kind: Deployment metadata: name: {{ include \"nginx-demo.fullname\" . }} labels: {{- include \"nginx-demo.labels\" . | nindent 4 }} spec: replicas: {{ .Values.replicaCount }} selector: matchLabels: app: {{ include \"nginx-demo.name\" . }} template: metadata: labels: app: {{ include \"nginx-demo.name\" . }} spec: containers: - name: nginx image: \"{{ .Values.image.repository }}:{{ .Values.image.tag }}\" imagePullPolicy: {{ .Values.image.pullPolicy }} ports: - containerPort: 80 🔗 templates/service.yaml apiVersion: v1 kind: Service metadata: name: {{ include \"nginx-demo.fullname\" . }} labels: {{- include \"nginx-demo.labels\" . | nindent 4 }} spec: type: {{ .Values.service.type }} ports: - port: {{ .Values.service.port }} targetPort: 80 protocol: TCP name: http selector: app: {{ include \"nginx-demo.name\" . }} 🧠 templates/_helpers.tpl {{- define \"nginx-demo.name\" -}} nginx {{- end }} {{- define \"nginx-demo.fullname\" -}} {{ .Release.Name }}-nginx {{- end }} {{- define \"nginx-demo.labels\" -}} app.kubernetes.io/name: {{ include \"nginx-demo.name\" . }} helm.sh/chart: {{ .Chart.Name }}-{{ .Chart.Version }} app.kubernetes.io/instance: {{ .Release.Name }} app.kubernetes.io/managed-by: {{ .Release.Service }} {{- end }} 📝 templates/notes.txt NGINX has been deployed successfully! You can access it within the cluster using: kubectl port-forward svc/{{ include \"nginx-demo.fullname\" . }} 8080:{{ .Values.service.port }} Then open your browser at: http://localhost:8080/ ✅ templates/tests/test-connection.yaml apiVersion: v1 kind: Pod metadata: name: \"{{ include \"nginx-demo.fullname\" . }}-test\" labels: {{- include \"nginx-demo.labels\" . | nindent 4 }} annotations: \"helm.sh/hook\": test spec: containers: - name: wget image: busybox command: ['wget'] args: ['{{ include \"nginx-demo.fullname\" . }}:{{ .Values.service.port }}'] restartPolicy: Never 🚀 Deploy the Chart helm install my-nginx ./nginx-demo 🧪 Run Helm Tests helm test my-nginx This complete example gives you a production-grade Helm chart foundation for deploying NGINX, including best practices like helpers, notes, and tests.",
    "tags": [],
    "title": "Creating Helm Charts ",
    "uri": "/helm/04.helm/index.html"
  },
  {
    "breadcrumb": "",
    "content": "🎯 Objective Learn how to create, package, and host Helm charts for two microservices — Order and Delivery — in a GitHub-based Helm repository using busybox as a placeholder image.\n🔧 Prerequisites Helm installed on your local machine A configured Kubernetes cluster A GitHub account to host your Helm repository kubectl CLI configured for your cluster 🏗️ Step 1: Create the Helm Charts Set up project structure:\nmkdir -p helm-registry/{order,delivery} cd helm-registry Create Helm charts:\nhelm create order helm create delivery 🛠️ Step 2: Customize Helm Charts Shared Deployment Template apiVersion: apps/v1 kind: Deployment metadata: name: {{ .Release.Name }}-{{ .Chart.Name }} labels: app: {{ .Chart.Name }} spec: replicas: 1 selector: matchLabels: app: {{ .Chart.Name }} template: metadata: labels: app: {{ .Chart.Name }} spec: containers: - name: {{ .Chart.Name }} image: {{ .Values.image.repository }}:{{ .Values.image.tag }} command: ['sh', '-c', 'echo {{ .Values.appMessage }}; sleep 3600'] imagePullPolicy: {{ .Values.image.pullPolicy }} 🔧 Order Chart – values.yaml image: repository: busybox tag: latest pullPolicy: IfNotPresent appMessage: \"Order Service is running\" 🔧 Delivery Chart – values.yaml image: repository: busybox tag: latest pullPolicy: IfNotPresent appMessage: \"Delivery Service is running\" 📦 Step 3: Package the Helm Charts helm package order helm package delivery helm repo index . This will generate .tgz packages and an index.yaml file.\n🌐 Step 4: Host Your Repo on GitHub Create a GitHub repository (e.g., helm-registry)\nInitialize Git and push content:\ngit init git remote add origin https://github.com/\u003cyour-username\u003e/helm-registry.git git add . git commit -m \"Add Order and Delivery Helm charts\" git push -u origin main Enable GitHub Pages\nGo to Settings → Pages Choose the main branch as the source and save 🚀 Step 5: Use Your GitHub-hosted Helm Repo Add your custom Helm repo:\nhelm repo add teamcharts https://\u003cyour-username\u003e.github.io/helm-registry helm repo update Search for your charts:\nhelm search repo teamcharts Install a service:\nhelm install order-app teamcharts/order helm install delivery-app teamcharts/delivery ✅ With this setup, you now have a functional Helm chart repository hosted on GitHub — ideal for internal services, demos, or even production use cases.",
    "description": "🎯 Objective Learn how to create, package, and host Helm charts for two microservices — Order and Delivery — in a GitHub-based Helm repository using busybox as a placeholder image.\n🔧 Prerequisites Helm installed on your local machine A configured Kubernetes cluster A GitHub account to host your Helm repository kubectl CLI configured for your cluster 🏗️ Step 1: Create the Helm Charts Set up project structure:\nmkdir -p helm-registry/{order,delivery} cd helm-registry Create Helm charts:",
    "tags": [],
    "title": "Hosting Helm Charts on GitHub",
    "uri": "/05.helm/index.html"
  },
  {
    "breadcrumb": "",
    "content": "🎯 Objective Learn how to create, package, and host Helm charts for two microservices — Order and Delivery — in a GitHub-based Helm repository using busybox as a placeholder image.\n🔧 Prerequisites Helm installed on your local machine A configured Kubernetes cluster A GitHub account to host your Helm repository kubectl CLI configured for your cluster 🏗️ Step 1: Create the Helm Charts Set up project structure:\nmkdir -p helm-registry/{order,delivery} cd helm-registry Create Helm charts:\nhelm create order helm create delivery 🛠️ Step 2: Customize Helm Charts Shared Deployment Template apiVersion: apps/v1 kind: Deployment metadata: name: {{ .Release.Name }}-{{ .Chart.Name }} labels: app: {{ .Chart.Name }} spec: replicas: 1 selector: matchLabels: app: {{ .Chart.Name }} template: metadata: labels: app: {{ .Chart.Name }} spec: containers: - name: {{ .Chart.Name }} image: {{ .Values.image.repository }}:{{ .Values.image.tag }} command: ['sh', '-c', 'echo {{ .Values.appMessage }}; sleep 3600'] imagePullPolicy: {{ .Values.image.pullPolicy }} 🔧 Order Chart – values.yaml image: repository: busybox tag: latest pullPolicy: IfNotPresent appMessage: \"Order Service is running\" 🔧 Delivery Chart – values.yaml image: repository: busybox tag: latest pullPolicy: IfNotPresent appMessage: \"Delivery Service is running\" 📦 Step 3: Package the Helm Charts helm package order helm package delivery helm repo index . This will generate .tgz packages and an index.yaml file.\n🌐 Step 4: Host Your Repo on GitHub Create a GitHub repository (e.g., helm-registry)\nInitialize Git and push content:\ngit init git remote add origin https://github.com/\u003cyour-username\u003e/helm-registry.git git add . git commit -m \"Add Order and Delivery Helm charts\" git push -u origin main Enable GitHub Pages\nGo to Settings → Pages Choose the main branch as the source and save 🚀 Step 5: Use Your GitHub-hosted Helm Repo Add your custom Helm repo:\nhelm repo add teamcharts https://\u003cyour-username\u003e.github.io/helm-registry helm repo update Search for your charts:\nhelm search repo teamcharts Install a service:\nhelm install order-app teamcharts/order helm install delivery-app teamcharts/delivery ✅ With this setup, you now have a functional Helm chart repository hosted on GitHub — ideal for internal services, demos, or even production use cases.",
    "description": "🎯 Objective Learn how to create, package, and host Helm charts for two microservices — Order and Delivery — in a GitHub-based Helm repository using busybox as a placeholder image.\n🔧 Prerequisites Helm installed on your local machine A configured Kubernetes cluster A GitHub account to host your Helm repository kubectl CLI configured for your cluster 🏗️ Step 1: Create the Helm Charts Set up project structure:\nmkdir -p helm-registry/{order,delivery} cd helm-registry Create Helm charts:",
    "tags": [],
    "title": "Hosting Helm Charts on GitHub",
    "uri": "/helm/05.helm/index.html"
  },
  {
    "breadcrumb": "",
    "content": "🔍 Preview Manifests Before Installing To preview the rendered Kubernetes manifests from a Helm chart without installing it, use:\nhelm template \u003crelease-name\u003e \u003cchart-path-or-name\u003e Example: helm template my-nginx bitnami/nginx 🧪 Simulate Installation (Dry Run) To simulate an install with all validations (including custom values):\nhelm install \u003crelease-name\u003e \u003cchart-path-or-name\u003e --dry-run --debug Example: helm install my-nginx bitnami/nginx --dry-run --debug 📥 Get Values from Existing Release To retrieve the custom values used in an existing Helm release:\nhelm get values \u003crelease-name\u003e -n \u003cnamespace\u003e Example: helm get values my-nginx -n default To get all values including defaults and overrides (merged output):\nhelm get values \u003crelease-name\u003e -n \u003cnamespace\u003e --all Example: helm get values my-nginx -n default --all 📄 Get Default values.yaml from a Helm Chart To get the default values.yaml file from a Helm chart before installing it, use:\nhelm show values \u003cchart-name\u003e 📦 Example (from a remote repository): helm show values bitnami/nginx 📁 Example (from a local chart directory): helm show values ./mychart This command prints all the default configuration options supported by the chart.\n💾 Save Default Values for Customization You can redirect the output to a file, edit it, and use it during installation:\nhelm show values bitnami/nginx \u003e custom-values.yaml Then install with:\nhelm install my-nginx bitnami/nginx --values custom-values.yaml ✅ This is a best practice for controlled and repeatable deployments.\n🔧 Using -f, --values, and --set in Helm Helm allows customization of charts using:\n-f or --values to supply a YAML file with configuration overrides. --set to pass values inline via the command line. 📁 Using -f or --values (YAML file) helm install my-nginx bitnami/nginx -f custom-values.yaml helm upgrade my-nginx bitnami/nginx -f dev-values.yaml -n dev You can also supply multiple files in order of precedence:\nhelm install my-nginx bitnami/nginx -f base.yaml -f prod.yaml The last file overrides values from the previous ones.\n💡 Using --set (Inline values) Set a single value inline:\nhelm install my-nginx bitnami/nginx --set service.type=LoadBalancer Set multiple values inline:\nhelm install my-nginx bitnami/nginx \\ --set replicaCount=2 \\ --set image.tag=1.23.0 \\ --set service.type=NodePort 🔄 Combine --set and --values You can combine both options. Inline --set overrides the values in the file:\nhelm install my-nginx bitnami/nginx \\ -f custom-values.yaml \\ --set service.type=LoadBalancer 📝 Set Nested/Array Values with --set For nested keys:\nhelm install my-nginx bitnami/nginx \\ --set metrics.enabled=true \\ --set ingress.enabled=true \\ --set ingress.hostname=nginx.example.com ✅ Use --values for maintainable configurations,\n✅ Use --set for quick overrides or scripting.",
    "description": "🔍 Preview Manifests Before Installing To preview the rendered Kubernetes manifests from a Helm chart without installing it, use:\nhelm template \u003crelease-name\u003e \u003cchart-path-or-name\u003e Example: helm template my-nginx bitnami/nginx 🧪 Simulate Installation (Dry Run) To simulate an install with all validations (including custom values):\nhelm install \u003crelease-name\u003e \u003cchart-path-or-name\u003e --dry-run --debug Example: helm install my-nginx bitnami/nginx --dry-run --debug 📥 Get Values from Existing Release To retrieve the custom values used in an existing Helm release:",
    "tags": [],
    "title": "Additional",
    "uri": "/additional/index.html"
  },
  {
    "breadcrumb": "",
    "content": "🔍 Preview Manifests Before Installing To preview the rendered Kubernetes manifests from a Helm chart without installing it, use:\nhelm template \u003crelease-name\u003e \u003cchart-path-or-name\u003e Example: helm template my-nginx bitnami/nginx 🧪 Simulate Installation (Dry Run) To simulate an install with all validations (including custom values):\nhelm install \u003crelease-name\u003e \u003cchart-path-or-name\u003e --dry-run --debug Example: helm install my-nginx bitnami/nginx --dry-run --debug 📥 Get Values from Existing Release To retrieve the custom values used in an existing Helm release:\nhelm get values \u003crelease-name\u003e -n \u003cnamespace\u003e Example: helm get values my-nginx -n default To get all values including defaults and overrides (merged output):\nhelm get values \u003crelease-name\u003e -n \u003cnamespace\u003e --all Example: helm get values my-nginx -n default --all 📄 Get Default values.yaml from a Helm Chart To get the default values.yaml file from a Helm chart before installing it, use:\nhelm show values \u003cchart-name\u003e 📦 Example (from a remote repository): helm show values bitnami/nginx 📁 Example (from a local chart directory): helm show values ./mychart This command prints all the default configuration options supported by the chart.\n💾 Save Default Values for Customization You can redirect the output to a file, edit it, and use it during installation:\nhelm show values bitnami/nginx \u003e custom-values.yaml Then install with:\nhelm install my-nginx bitnami/nginx --values custom-values.yaml ✅ This is a best practice for controlled and repeatable deployments.\n🔧 Using -f, --values, and --set in Helm Helm allows customization of charts using:\n-f or --values to supply a YAML file with configuration overrides. --set to pass values inline via the command line. 📁 Using -f or --values (YAML file) helm install my-nginx bitnami/nginx -f custom-values.yaml helm upgrade my-nginx bitnami/nginx -f dev-values.yaml -n dev You can also supply multiple files in order of precedence:\nhelm install my-nginx bitnami/nginx -f base.yaml -f prod.yaml The last file overrides values from the previous ones.\n💡 Using --set (Inline values) Set a single value inline:\nhelm install my-nginx bitnami/nginx --set service.type=LoadBalancer Set multiple values inline:\nhelm install my-nginx bitnami/nginx \\ --set replicaCount=2 \\ --set image.tag=1.23.0 \\ --set service.type=NodePort 🔄 Combine --set and --values You can combine both options. Inline --set overrides the values in the file:\nhelm install my-nginx bitnami/nginx \\ -f custom-values.yaml \\ --set service.type=LoadBalancer 📝 Set Nested/Array Values with --set For nested keys:\nhelm install my-nginx bitnami/nginx \\ --set metrics.enabled=true \\ --set ingress.enabled=true \\ --set ingress.hostname=nginx.example.com ✅ Use --values for maintainable configurations,\n✅ Use --set for quick overrides or scripting.",
    "description": "🔍 Preview Manifests Before Installing To preview the rendered Kubernetes manifests from a Helm chart without installing it, use:\nhelm template \u003crelease-name\u003e \u003cchart-path-or-name\u003e Example: helm template my-nginx bitnami/nginx 🧪 Simulate Installation (Dry Run) To simulate an install with all validations (including custom values):\nhelm install \u003crelease-name\u003e \u003cchart-path-or-name\u003e --dry-run --debug Example: helm install my-nginx bitnami/nginx --dry-run --debug 📥 Get Values from Existing Release To retrieve the custom values used in an existing Helm release:",
    "tags": [],
    "title": "Additional",
    "uri": "/helm/additional/index.html"
  },
  {
    "breadcrumb": "",
    "content": "",
    "description": "",
    "tags": [],
    "title": "Categories",
    "uri": "/categories/index.html"
  },
  {
    "breadcrumb": "GIT Version Control System",
    "content": "🚀 Git Tutorial from Start — With Real-Time Examples 📘 Table of Contents 🚀 Git Tutorial from Start — With Real-Time Examples 📘 Table of Contents 📌 What is Git? 🧰 Installing Git For Linux: For macOS: For Windows: ⚙️ Git Configuration 🔄 Basic Git Workflow 🧬 Cloning a Repository ✍️ Making Changes \u0026 Committing 🌿 Branching and Merging 🔄 Real-Time Example: Feature Branch Workflow 📦 Stashing Changes 🌐 Working with Remotes 📜 Git Log and History 🔙 Undoing Things 🚫 .gitignore File 🏷️ Git Tags ✅ Conclusion 📌 What is Git? Git is a distributed version control system. Tracks changes in source code during software development. Helps teams collaborate on code. 🧰 Installing Git For Linux: sudo apt update sudo apt install git For macOS: brew install git For Windows: Download from: https://git-scm.com/downloads ⚙️ Git Configuration git config --global user.name \"Your Name\" git config --global user.email \"you@example.com\" git config --list # verify settings 🔄 Basic Git Workflow git init # Initialize a Git repository git status # Check current status git add file.txt # Stage a file git commit -m \"Added file\" # Commit with message 🧬 Cloning a Repository git clone https://github.com/yourusername/project.git ✍️ Making Changes \u0026 Committing echo \"Hello Git\" \u003e hello.txt git add hello.txt git commit -m \"Added hello.txt file\" 🌿 Branching and Merging git branch # List branches git branch feature-x # Create a new branch git checkout feature-x # Switch to branch # Make changes and commit git checkout main git merge feature-x # Merge branch into main 🔄 Real-Time Example: Feature Branch Workflow Scenario: You are adding a login feature.\ngit checkout -b feature/login # Add login logic to login.js git add login.js git commit -m \"Add login feature\" git push origin feature/login # Open a Merge Request (MR) on GitLab/GitHub After MR approval:\ngit checkout main git pull origin main git merge feature/login git push origin main 📦 Stashing Changes git stash # Save uncommitted changes git pull origin main git stash pop # Apply stashed changes 🌐 Working with Remotes git remote -v # Show configured remotes git remote add origin \u003crepo-url\u003e # Add remote repository git push -u origin main # Push code to remote git pull origin main # Pull latest changes 📜 Git Log and History git log # View commit logs git log --oneline --graph --all # Pretty graph format 🔙 Undoing Things git checkout -- file.txt # Discard uncommitted changes git reset HEAD~1 # Undo last commit (keep changes) git revert \u003ccommit-id\u003e # Revert a specific commit 🚫 .gitignore File Create a .gitignore file in the project root to ignore files/folders.\n# .gitignore example *.log node_modules/ .env .idea/ .DS_Store 🏷️ Git Tags git tag v1.0 # Lightweight tag git tag -a v1.1 -m \"Release v1.1\" # Annotated tag git push origin --tags # Push tags to remote ✅ Conclusion Git is essential for modern development workflows. Use branches and MRs for cleaner collaboration. Practice using add, commit, push, and pull regularly. Use git status and git log to understand project state. 🙌 Happy Coding with Git! Keep committing and stay versioned!",
    "description": "🚀 Git Tutorial from Start — With Real-Time Examples 📘 Table of Contents 🚀 Git Tutorial from Start — With Real-Time Examples 📘 Table of Contents 📌 What is Git? 🧰 Installing Git For Linux: For macOS: For Windows: ⚙️ Git Configuration 🔄 Basic Git Workflow 🧬 Cloning a Repository ✍️ Making Changes \u0026 Committing 🌿 Branching and Merging 🔄 Real-Time Example: Feature Branch Workflow 📦 Stashing Changes 🌐 Working with Remotes 📜 Git Log and History 🔙 Undoing Things 🚫 .gitignore File 🏷️ Git Tags ✅ Conclusion 📌 What is Git? Git is a distributed version control system. Tracks changes in source code during software development. Helps teams collaborate on code. 🧰 Installing Git For Linux: sudo apt update sudo apt install git For macOS: brew install git For Windows: Download from: https://git-scm.com/downloads ⚙️ Git Configuration git config --global user.name \"Your Name\" git config --global user.email \"you@example.com\" git config --list # verify settings 🔄 Basic Git Workflow git init # Initialize a Git repository git status # Check current status git add file.txt # Stage a file git commit -m \"Added file\" # Commit with message 🧬 Cloning a Repository git clone https://github.com/yourusername/project.git ✍️ Making Changes \u0026 Committing echo \"Hello Git\" \u003e hello.txt git add hello.txt git commit -m \"Added hello.txt file\" 🌿 Branching and Merging git branch # List branches git branch feature-x # Create a new branch git checkout feature-x # Switch to branch # Make changes and commit git checkout main git merge feature-x # Merge branch into main 🔄 Real-Time Example: Feature Branch Workflow Scenario: You are adding a login feature.",
    "tags": [],
    "title": "Git",
    "uri": "/git/git01/index.html"
  },
  {
    "breadcrumb": "GIT Version Control System",
    "content": "🔍 Advanced git log Examples git log is highly customizable. Here are real-world examples:\n📦 Basic Commit Log git log Shows full commit history with author, date, and message.\n🧵 One-line Log (Condensed View) git log --oneline Shows each commit as a single line: useful for quick scanning.\n🌲 Visual Branch Graph git log --oneline --graph --all Displays commit history as a branch graph across all branches.\n📆 Log with Dates git log --pretty=format:\"%h - %an, %ar : %s\" Custom format: shows commit hash, author, relative date, and message.\n🔎 Filter by Author git log --author=\"nirpendra\" Shows only commits made by a specific author.\n🕐 Commits from the Last 7 Days git log --since=\"7 days ago\" Or filter between two dates:\ngit log --since=\"2024-06-01\" --until=\"2024-06-30\" 📁 Log for a Specific File git log -- \u003cfile-path\u003e View changes made to a particular file.\nExample:\ngit log -- src/main.py 🧾 Show Diff with Each Commit git log -p Includes the patch (code changes) with each commit.\n🧰 Combined Format: Pretty + Graph + Oneline git log --pretty=format:\"%C(yellow)%h%Creset %Cgreen%ad%Creset %C(cyan)%an%Creset - %s\" --date=short --graph This gives a colorful, structured view:\nHash in yellow Date in green Author in cyan 🔢 Limit the Number of Commits git log -n 5 Shows the last 5 commits only.\n📊 Stats Per Commit git log --stat Displays each commit along with the number of lines added/removed and the file names.\n📜 List Files Modified in Last Commit git log -1 --name-only 🔐 View Only Merge Commits git log --merges 💡 Tip: You can combine these flags for powerful custom outputs! Example:\ngit log --oneline --author=\"nirpendra\" --since=\"1 week ago\"",
    "description": "🔍 Advanced git log Examples git log is highly customizable. Here are real-world examples:\n📦 Basic Commit Log git log Shows full commit history with author, date, and message.\n🧵 One-line Log (Condensed View) git log --oneline Shows each commit as a single line: useful for quick scanning.\n🌲 Visual Branch Graph git log --oneline --graph --all Displays commit history as a branch graph across all branches.",
    "tags": [],
    "title": "Git Logs",
    "uri": "/git/git02/index.html"
  },
  {
    "breadcrumb": "GIT Version Control System",
    "content": "📜 Git Log and History git log git log --oneline git log --oneline --graph --all 🔙 Undoing Things git checkout -- file git revert \u003ccommit\u003e 🧠 Understanding git reset git reset --soft HEAD~1 # Keep changes staged git reset --mixed HEAD~1 # Keep changes, unstage git reset --hard HEAD~1 # Discard changes 🔍 Advanced git log Examples git log # Full history git log --oneline # Short view git log --graph --oneline # Tree view git log --author=\"name\" git log --since=\"7 days ago\" git log -p # Show diffs git log --stat # File changes git log -1 --name-only # Files in last commit git log --merges # Only merge commits 🚫 .gitignore File *.log .env node_modules/ .idea/ 🏷️ Git Tags git tag v1.0 git tag -a v1.1 -m \"Release v1.1\" git push origin --tags ✅ Conclusion Use Git daily. Learn branching, logs, reset, and collaboration with remotes. Practice makes perfect!\n🙌 Happy Coding with Git!",
    "description": "📜 Git Log and History git log git log --oneline git log --oneline --graph --all 🔙 Undoing Things git checkout -- file git revert \u003ccommit\u003e 🧠 Understanding git reset git reset --soft HEAD~1 # Keep changes staged git reset --mixed HEAD~1 # Keep changes, unstage git reset --hard HEAD~1 # Discard changes 🔍 Advanced git log Examples git log # Full history git log --oneline # Short view git log --graph --oneline # Tree view git log --author=\"name\" git log --since=\"7 days ago\" git log -p # Show diffs git log --stat # File changes git log -1 --name-only # Files in last commit git log --merges # Only merge commits 🚫 .gitignore File *.log .env node_modules/ .idea/ 🏷️ Git Tags git tag v1.0 git tag -a v1.1 -m \"Release v1.1\" git push origin --tags ✅ Conclusion Use Git daily. Learn branching, logs, reset, and collaboration with remotes. Practice makes perfect!",
    "tags": [],
    "title": "Git More Examples ",
    "uri": "/git/git_tutorial/index.html"
  },
  {
    "breadcrumb": "GIT Version Control System",
    "content": "🧩 Git Merge Methods Explained 🔸 1. Fast-Forward Merge 📌 What: Moves the branch pointer forward because there’s no divergent history.\n🧪 Example: git checkout main git merge feature-branch ✅ If main is behind feature-branch but has no new commits, Git just moves main forward — no merge commit is created.\n📊 Result: No extra commit. Clean history. Only possible when histories are linear (no parallel commits). 🔸 2. Three-Way Merge (Default) 📌 What: Used when branches diverged — Git creates a merge commit.\n🧪 Example: git checkout main git merge feature-branch 🔄 If both main and feature-branch have new commits, Git creates a merge commit to tie them.\n📊 Result: Merge commit created. Retains full history of both branches. Good for preserving commit context. 🔸 3. Squash Merge 📌 What: Combines all commits from the feature branch into a single commit on the target branch.\n🧪 Example: git checkout main git merge --squash feature-branch git commit -m \"Add feature X\" 📝 All feature-branch commits are flattened into one.\n📊 Result: Clean, single commit. Good for simplifying history. Loses detailed history of feature-branch. 🔸 4. Rebase + Fast-Forward 📌 What: Rewrites feature branch history onto base branch — keeps history linear and avoids merge commits.\n🧪 Example: git checkout feature-branch git rebase main git checkout main git merge --ff-only feature-branch 📈 Keeps history tidy and linear.\n📊 Result: No merge commits. Linear history. Can be risky if rebasing shared branches (changes commit hashes). 🔸 5. No-Fast-Forward Merge (--no-ff) 📌 What: Forces Git to always create a merge commit, even if a fast-forward is possible.\n🧪 Example: git merge --no-ff feature-branch 🔗 Use this to clearly show a branch was merged, even if no divergence.\n📊 Result: Always a merge commit. Good for clear separation of features in history. 🔍 Summary Table Merge Method Merge Commit History Type Use Case Fast-Forward ❌ No Linear Simple updates Three-Way Merge ✅ Yes Diverged Default for complex merges Squash Merge ❌ One commit Simplified Clean history, single logical change Rebase + FF ❌ No Linear Clean history before merge No-FF ✅ Yes Always visible Always document a merge explicitly 🧠 Best Practices ✅ Use squash for feature branches in solo/team projects to simplify history. ✅ Use no-ff in protected/main branches for clear audit trails. ✅ Use rebase to clean up local commits before merging. 🔁 Understanding git rebase 🔹 What is git rebase? git rebase is used to move or combine a sequence of commits to a new base commit. It is often used to maintain a cleaner, linear project history.\nUnlike merge, which creates a new commit, rebase re-applies commits on top of another branch.\n🔹 Syntax git rebase \u003cupstream-branch\u003e Example:\ngit checkout feature git rebase main This reapplies your feature branch commits on top of the latest main.\n🔹 Common Use Case: Updating Feature Branch # Assume you're on feature branch git checkout feature/login git fetch origin git rebase origin/main ✅ This puts your feature branch on top of the latest main, as if it was created from it.\n🔹 Resolving Conflicts During Rebase If conflicts occur:\n# After editing the file to fix conflicts git add \u003cresolved-file\u003e git rebase --continue To skip the current commit:\ngit rebase --skip To abort the rebase and return to the previous state:\ngit rebase --abort 🔄 Interactive Rebase Use this to edit, squash, or reword commits.\ngit rebase -i HEAD~3 Example interactive menu:\npick 3f5e1f9 Added login form\rpick 89d2ac3 Fixed typo in login\rsquash d14e7a3 Updated form styles Change pick to:\nreword — change the commit message squash — combine commits into one edit — pause to change code during rebase 🆚 Rebase vs Merge Feature git merge git rebase History Keeps history with a merge commit Creates a linear history Commit Graph May look like a tree Looks like a straight line Use When You want to preserve all changes You want a clean history 🚫 Don’t Rebase Shared Branches ⚠️ Avoid using git rebase on branches that others are working on (i.e., already pushed/shared), unless you coordinate with your team.\n🔧 Example: Clean Up Before Merge Request git checkout feature/payment git rebase -i HEAD~5 # squash into a single commit Then:\ngit push -f origin feature/payment 💡 Tip: Use git log --oneline --graph before and after rebase to visualize the change.",
    "description": "🧩 Git Merge Methods Explained 🔸 1. Fast-Forward Merge 📌 What: Moves the branch pointer forward because there’s no divergent history.\n🧪 Example: git checkout main git merge feature-branch ✅ If main is behind feature-branch but has no new commits, Git just moves main forward — no merge commit is created.\n📊 Result: No extra commit. Clean history. Only possible when histories are linear (no parallel commits). 🔸 2. Three-Way Merge (Default) 📌 What: Used when branches diverged — Git creates a merge commit.",
    "tags": [],
    "title": "Git Rebase and Merge",
    "uri": "/git/git04/index.html"
  },
  {
    "breadcrumb": "",
    "content": "🧾 What is Git? Git is a free, open-source, and distributed version control system designed to handle everything from small to very large projects with speed and efficiency.\n🔧 In Simple Terms Git helps track changes in your code (or any files), collaborate with others, and go back in time to previous versions.\n🧠 Key Features of Git Feature Description ✅ Distributed Every developer has a full copy of the repository. ⏳ Version Tracking Keeps a history of every change (who, what, when, and why). 🧪 Branching \u0026 Merging Create isolated environments (branches), and combine them when ready. ⚡ Fast \u0026 Efficient Designed to be fast — especially for large projects. 🔐 Secure Uses checksums (SHA-1) to ensure data integrity. 📦 Git vs GitHub Git GitHub Version control tool (CLI) Web-based platform for Git repositories Works locally Requires internet/browser for collaboration Can be used independently Built on top of Git 📂 Real-World Analogy Imagine writing a book:\nGit keeps snapshots of your book at every stage. You can always go back to Chapter 1 or see who edited Chapter 3. You can write Chapter 4 separately (branch), and merge it when done. 💻 Common Git Commands Command Purpose git init Initialize a new Git repo git clone \u003curl\u003e Copy a remote repo git status Check file status git add \u003cfile\u003e Stage changes git commit -m \"message\" Save snapshot git push Upload changes to remote git pull Fetch and merge changes from remote git branch List branches git checkout -b \u003cbranch\u003e Create and switch to a new branch git merge \u003cbranch\u003e Merge another branch into current one 🧑‍🤝‍🧑 Who Uses Git? Developers DevOps Engineers System Admins Writers Data Scientists Basically, anyone who works with files that change over time.",
    "description": "🧾 What is Git? Git is a free, open-source, and distributed version control system designed to handle everything from small to very large projects with speed and efficiency.\n🔧 In Simple Terms Git helps track changes in your code (or any files), collaborate with others, and go back in time to previous versions.\n🧠 Key Features of Git Feature Description ✅ Distributed Every developer has a full copy of the repository. ⏳ Version Tracking Keeps a history of every change (who, what, when, and why). 🧪 Branching \u0026 Merging Create isolated environments (branches), and combine them when ready. ⚡ Fast \u0026 Efficient Designed to be fast — especially for large projects. 🔐 Secure Uses checksums (SHA-1) to ensure data integrity. 📦 Git vs GitHub Git GitHub Version control tool (CLI) Web-based platform for Git repositories Works locally Requires internet/browser for collaboration Can be used independently Built on top of Git 📂 Real-World Analogy Imagine writing a book:",
    "tags": [],
    "title": "GIT Version Control System",
    "uri": "/git/index.html"
  },
  {
    "breadcrumb": "",
    "content": "",
    "description": "",
    "tags": [],
    "title": "Tags",
    "uri": "/tags/index.html"
  },
  {
    "breadcrumb": "",
    "content": "",
    "description": "",
    "tags": [],
    "title": "Vmwares",
    "uri": "/vmware/index.html"
  }
]
